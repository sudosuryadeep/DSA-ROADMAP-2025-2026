# Hashing in data structure

**Hashing** is a technique used in data structures that efficiently stores and retrieves data in a way that allows for quick access.

* Hashing involves mapping data to a specific index in a hash table (an array of items) using a **hash function.** It enables fast retrieval of information based on its key.  
* The great thing about hashing is, we can achieve all three operations (search, insert and delete) in O(1) time on average.  
* Hashing is mainly used to implement a set of distinct items (only keys) and dictionaries (key value pairs).

## **Components of Hashing**

There are majorly three components of hashing:

1. **Key:** A Key can be anything string or integer which is fed as input in the hash function the technique that determines an index or location for storage of an item in a data structure.  
2. **Hash Function:** Receives the input key and returns the index of an element in an array called a hash table. The index is known as the hash index .  
3. **Hash Table:** Hash table is typically an array of lists. It stores values corresponding to the keys. Hash stores the data in an associative manner in an array where each data value has its own unique index.

# How does Hashing work?

Let’s say we have a small set of strings:  
 `{ "al", "dm", "ghe" }`  
 We want to store these in a hash table of fixed size using a simple hash function.

### **Step 1: Character Mapping**

First, we assign each lowercase letter a numerical value based on its position in the alphabet:

* `'a'` \= 1, `'b'` \= 2, ..., `'z'` \= 26

  ### **Step 2: String to Number Conversion**

Now, for each string, we compute a numerical value by summing the mapped values of its characters:

* `"al"` → `'a'` \+ `'l'` \= 1 \+ 12 \= **13**

* `"dm"` → `'d'` \+ `'m'` \= 4 \+ 13 \= **17**

* `"ghe"` → `'g'` \+ `'h'` \+ `'e'` \= 7 \+ 8 \+ 5 \= **20**

  ### **Step 3: Applying the Hash Function**

We define a simple hash function as:

`hash_index = (sum of character values) % table_size`

Let’s assume our hash table has `table_size = 7`.

Now we compute the index for each string:

* `"al"` → 13 % 7 \= **6**

* `"dm"` → 17 % 7 \= **3**

* `"ghe"` → 20 % 7 \= **6**

  ### **Step 4: Storing in the Table**

We now place the strings into their corresponding index in the hash table. However, notice that both `"al"` and `"ghe"` map to index 6 — this is called a **collision**. In a real hash table, we’d need a strategy to resolve such collisions (e.g., chaining, open addressing).

**Here are some terms you must know:**

## **Collision in Hashing**

When two or more keys have the same hash value, a **collision** happens. If we consider the above example, the hash function we used is the sum of the letters, but if we examined the hash function closely then the problem can be easily visualised that for different strings same hash value is being generated by the hash function.

For example: {“ab”, “ba”} both have the same hash value, and string {“cd”,”be”} also generate the same hash value, etc. This is known as **collision** and it creates problem in searching, insertion, deletion, and updating of value.

## **Load Factor in Hashing**

The load factor of the hash table can be defined as the number of items the hash table contains divided by the size of the hash table. Load factor is the decisive parameter that is used when we want to rehash the previous hash function or want to add more elements to the existing hash table.

It helps us in determining the efficiency of the hash function i.e. it tells whether the hash function which we are using is distributing the keys uniformly or not in the hash table.

*Load Factor \= Total elements in hash table/ Size of hash table*

## **Rehashing**

As the name suggests, rehashing means hashing again. Basically, when the load factor increases to more than its predefined value (the default value of the load factor is 0.75), the complexity increases. So to overcome this, the size of the array is increased (doubled) and all the values are hashed again and stored in the new double-sized array to maintain a low load factor and low complexity.

**How Rehashing is done?**  
Rehashing can be done as follows:

* For each addition of a new entry to the map, check the load factor.  
* If it's greater than its pre-defined value (or default value of 0.75 if not given), then Rehash.  
* For Rehash, make a new array of double the previous size and make it the new bucketarray.  
* Then traverse to each element in the old bucketArray and call the insert() for each so as to insert it into the new larger bucket array.

Here’s an explanation video which will help you understand this:

[Hashing \- Rehashing](https://www.youtube.com/watch?v=uaGWFN6djLw)

You can also look at the code given here:

[Load Factor and Rehashing \- GeeksforGeeks](https://www.geeksforgeeks.org/load-factor-and-rehashing/)

# **What is a HashMap?**

A **HashMap** (also called a dictionary or map) is a data structure that stores **key-value pairs**. It uses **hashing** to allow **average-case O(1)** time complexity for insertion, deletion, and lookup.

How it Works

1. **Keys** are passed into a **hash function**, which returns a hash code (usually an integer).

2. This hash code is **modded by the table size** to get an index.

3. The key-value pair is stored at that index in the hash table.

**Here’s an example (in python):**

```python
# Creating a HashMap
hashmap = {}

# Inserting key-value pairs
hashmap["apple"] = 3
hashmap["banana"] = 5
hashmap["orange"] = 2

# Accessing a value
print(hashmap["banana"])  # Output: 5

# Checking if a key exists
if "apple" in hashmap:
    print("Apple is present.")

# Deleting a key
del hashmap["orange"]

# Iterating through keys and values
for key, value in hashmap.items():
    print(f"{key}: {value}")
```


# Index Mapping

Index Mapping (also known as Trivial Hashing) is a simple form of hashing where the data is directly mapped to an index in a hash table. The hash function used in this method is typically the identity function, which maps the input data to itself. In this case, the key of the data is used as the index in the hash table, and the value is stored at that index.

For example, if we have a hash table of size 10 and we want to store the value "apple" with the key "a", the trivial hashing function would simply map the key "a" to the index "a" in the hash table, and store the value "apple" at that index.

To search any element *x* in the array. 

* If X is non-negative check if hash\[X\]\[0\] is 1 or not. If hash\[X\]\[0\] is one then the number is present else not present.  
* If X is negative take the absolute value of X and then check if hash\[X\]\[1\] is 1 or not. If hash\[X\]\[1\] is one then the number is present

**Implementing this in C++:**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAX 1000

// Since array is global, it is initialized as 0.
bool has[MAX + 1][2];

// Searching if X is present in the given array or not.
bool search(int X)
{
    if (X >= 0) {
        if (has[X][0] == 1)
            return true;
        else
            return false;
    }

    // If X is negative take the absolute value of X.
    X = abs(X);
    if (has[X][1] == 1)
        return true;

    return false;
}

void insert(int a[], int n)
{
    for (int i = 0; i < n; i++) {
        if (a[i] >= 0)
            has[a[i]][0] = 1;
        else
            has[abs(a[i])][1] = 1;
    }
}

// Driver code
int main()
{
    int a[] = { -1, 9, -5, -8, -5, -2 };
    int n = sizeof(a)/sizeof(a[0]);
    insert(a, n);
    int X = -5;
    if (search(X) == true)
        cout << "Present";
    else
        cout << "Not Present";
    return 0;
}
```


It is similar in Python and Javascript. You can check it out here; [https://www.geeksforgeeks.org/index-mapping-or-trivial-hashing-with-negatives-allowed/](https://www.geeksforgeeks.org/index-mapping-or-trivial-hashing-with-negatives-allowed/)

# Separate Chaining in Hashing

**Separate chaining** is a collision resolution technique where each index of the hash table points to a **linked list** (or any dynamic structure) that holds all elements mapping to that index.

Whenever two or more keys hash to the same index, instead of overwriting or probing for another slot, we simply append the new element to a list at that index. This list is called a **chain**.

Each chain is typically a singly linked list. So, if multiple keys produce the same hash value, they are stored sequentially in that list.

# Searching in Separate Chaining:

To find a key `K`, you:

1. Use the hash function to locate the index.  
2. Traverse the chain at that index.  
3. If you find an entry matching `K`, return it.  
4. If the chain ends and the key isn’t found, it means the key doesn’t exist.  
   

# Open Addressing in Hashing

Open Addressing is a collision resolution method where all elements are stored *directly in the hash table itself*. There are no external structures like linked lists or chains. When a collision occurs, the algorithm probes the table to find the next available slot using a specific strategy.

**How It Works:**

When a key hashes to an index that's already occupied:

* Instead of creating a chain, we search for another free slot using a probing technique.

* The probing continues until an empty slot is found, and the key is placed there.

All keys, whether collided or not, stay within the array. That’s why this method is sometimes called closed hashing.

**To learn in detail about these topics, you can visit** [https://www.geeksforgeeks.org/separate-chaining-collision-handling-technique-in-hashing/](https://www.geeksforgeeks.org/separate-chaining-collision-handling-technique-in-hashing/)  

and 

[https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)

**You can refer to these resources for a better clarity on this topic:**

**[Hashing | Maps | Time Complexity | Collisions | Division Rule of Hashing | Strivers A2Z DSA Course](https://www.youtube.com/watch?v=KEs5UyBJ39g&t=2464s)**

**[Understanding and implementing a Hash Table (in C)](https://youtu.be/2Ti5yvumFTU?t=3586)**

These will provide a visual explanation which will help you to understand deeper.

# Practice Questions:

Easy: 

* [https://leetcode.com/problems/two-sum/](https://leetcode.com/problems/two-sum/)  
* [https://leetcode.com/problems/contains-duplicate/](https://leetcode.com/problems/contains-duplicate/)  
* [https://leetcode.com/problems/valid-anagram/](https://leetcode.com/problems/valid-anagram/)  
* [https://leetcode.com/problems/ransom-note/](https://leetcode.com/problems/ransom-note/)  
* [https://leetcode.com/problems/intersection-of-two-arrays/](https://leetcode.com/problems/intersection-of-two-arrays/)

Medium:

* [https://leetcode.com/problems/group-anagrams/](https://leetcode.com/problems/group-anagrams/)  
* [https://leetcode.com/problems/top-k-frequent-elements/](https://leetcode.com/problems/top-k-frequent-elements/)  
* [https://leetcode.com/problems/longest-consecutive-sequence/](https://leetcode.com/problems/longest-consecutive-sequence/)

Hard:

* [https://leetcode.com/problems/minimum-window-substring/](https://leetcode.com/problems/minimum-window-substring/)  
* [https://leetcode.com/problems/substring-with-concatenation-of-all-words/](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)  
* [https://leetcode.com/problems/lru-cache/](https://leetcode.com/problems/lru-cache/)


  
